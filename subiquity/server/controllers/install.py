# Copyright 2020 Canonical, Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import logging
import os
import re
import shutil
import tempfile

from curtin.commands.install import (
    ERROR_TARFILE,
    INSTALL_LOG,
    )
from curtin.util import write_file

import yaml

from subiquitycore.async_helpers import (
    run_in_thread,
    )
from subiquitycore.context import with_context
from subiquitycore.lsb_release import lsb_release

from subiquity.common.apidef import API
from subiquity.common.errorreport import ErrorReportKind
from subiquity.common.types import (
    ApplicationState,
    )
from subiquity.journald import (
    journald_listen,
    )
from subiquity.server.curtin import (
    run_curtin_command,
    start_curtin_command,
    )
from subiquity.server.controller import (
    SubiquityController,
    )

log = logging.getLogger("subiquity.server.controllers.install")


class TracebackExtractor:

    start_marker = re.compile(r"^Traceback \(most recent call last\):")
    end_marker = re.compile(r"\S")

    def __init__(self):
        self.traceback = []
        self.in_traceback = False

    def feed(self, line):
        if not self.traceback and self.start_marker.match(line):
            self.in_traceback = True
        elif self.in_traceback and self.end_marker.match(line):
            self.traceback.append(line)
            self.in_traceback = False
        if self.in_traceback:
            self.traceback.append(line)


class InstallController(SubiquityController):

    endpoint = API.install

    def __init__(self, app):
        super().__init__(app)
        self.model = app.base_model

        self.unattended_upgrades_cmd = None
        self.unattended_upgrades_ctx = None
        self.tb_extractor = TracebackExtractor()

    def interactive(self):
        return True

    def stop_uu(self):
        if self.app.state == ApplicationState.UU_RUNNING:
            self.app.update_state(ApplicationState.UU_CANCELLING)
            self.app.aio_loop.create_task(self.stop_unattended_upgrades())

    def start(self):
        journald_listen(
            self.app.aio_loop, [self.app.log_syslog_id], self.log_event)
        self.install_task = self.app.aio_loop.create_task(self.install())

    def tpath(self, *path):
        return os.path.join(self.model.target, *path)

    def log_event(self, event):
        self.tb_extractor.feed(event['MESSAGE'])

    def write_config(self):
        config = self.model.render()
        config_location = '/var/log/installer/subiquity-curtin-install.conf'
        log_location = INSTALL_LOG
        if self.app.opts.dry_run:
            config_location = '.subiquity' + config_location
            log_location = '.subiquity' + INSTALL_LOG
        os.makedirs(os.path.dirname(config_location), exist_ok=True)
        os.makedirs(os.path.dirname(log_location), exist_ok=True)
        with open(config_location, 'w') as conf:
            datestr = '# Autogenerated by Subiquity: {} UTC\n'.format(
                str(datetime.datetime.utcnow()))
            conf.write(datestr)
            conf.write(yaml.dump(config))
        self.app.note_file_for_apport("CurtinConfig", config_location)
        self.app.note_file_for_apport("CurtinErrors", ERROR_TARFILE)
        self.app.note_file_for_apport("CurtinLog", log_location)
        return config_location

    @with_context(description="umounting /target dir")
    async def unmount_target(self, *, context, target):
        await run_curtin_command(self.app, context, 'unmount', '-t', target)
        if not self.app.opts.dry_run:
            shutil.rmtree(target)

    @with_context(
        description="installing system", level="INFO", childlevel="DEBUG")
    async def curtin_install(self, *, context, config_location):
        await run_curtin_command(
            self.app, context, 'install', config=config_location)

    @with_context()
    async def install(self, *, context):
        context.set('is-install-context', True)
        try:
            while True:
                self.app.update_state(ApplicationState.WAITING)

                await self.model.wait_install()

                if not self.app.interactive:
                    if 'autoinstall' in self.app.kernel_cmdline:
                        self.model.confirm()

                self.app.update_state(ApplicationState.NEEDS_CONFIRMATION)

                if await self.model.wait_confirmation():
                    break

            self.app.update_state(ApplicationState.RUNNING)

            self.config_location = self.write_config()

            if os.path.exists(self.model.target):
                await self.unmount_target(
                    context=context, target=self.model.target)

            await self.curtin_install(
                context=context, config_location=self.config_location)

            self.app.update_state(ApplicationState.POST_WAIT)

            await self.model.wait_postinstall()

            self.app.update_state(ApplicationState.POST_RUNNING)

            await self.postinstall(context=context)

            self.app.update_state(ApplicationState.DONE)
        except Exception:
            kw = {}
            if self.tb_extractor.traceback:
                kw["Traceback"] = "\n".join(self.tb_extractor.traceback)
            self.app.make_apport_report(
                ErrorReportKind.INSTALL_FAIL, "install failed", **kw)
            raise

    @with_context(
        description="final system configuration", level="INFO",
        childlevel="DEBUG")
    async def postinstall(self, *, context):
        autoinstall_path = os.path.join(
            self.app.root, 'var/log/installer/autoinstall-user-data')
        autoinstall_config = "#cloud-config\n" + yaml.dump(
            {"autoinstall": self.app.make_autoinstall()})
        write_file(autoinstall_path, autoinstall_config, mode=0o600)
        await self.configure_cloud_init(context=context)
        packages = await self.get_target_packages(context=context)
        for package in packages:
            await self.install_package(context=context, package=package)

        if self.model.network.has_network:
            self.app.update_state(ApplicationState.UU_RUNNING)
            policy = self.model.updates.updates
            await self.run_unattended_upgrades(context=context, policy=policy)
        await self.restore_apt_config(context=context)

    @with_context(description="configuring cloud-init")
    async def configure_cloud_init(self, context):
        await run_in_thread(self.model.configure_cloud_init)

    @with_context(description="calculating extra packages to install")
    async def get_target_packages(self, context):
        return await self.app.base_model.target_packages()

    @with_context(
        name="install_{package}",
        description="installing {package}")
    async def install_package(self, *, context, package):
        await run_curtin_command(
            self.app, context, 'system-install', '--', package)

    @with_context(description="restoring apt configuration")
    async def restore_apt_config(self, context):
        await self.app.command_runner.run(["umount", self.tpath('etc/apt')])
        if self.model.network.has_network:
            await run_curtin_command(
                self.app, context, "in-target", "-t", self.tpath(),
                "--", "apt-get", "update")
        else:
            await self.app.command_runner.run(
                ["umount", self.tpath('var/lib/apt/lists')])

    @with_context(description="downloading and installing {policy} updates")
    async def run_unattended_upgrades(self, context, policy):
        if self.app.opts.dry_run:
            aptdir = self.tpath("tmp")
        else:
            aptdir = self.tpath("etc/apt/apt.conf.d")
        os.makedirs(aptdir, exist_ok=True)
        apt_conf_contents = uu_apt_conf
        if policy == 'all':
            apt_conf_contents += uu_apt_conf_update_all
        else:
            apt_conf_contents += uu_apt_conf_update_security
        fname = 'zzzz-temp-installer-unattended-upgrade'
        with open(os.path.join(aptdir, fname), 'wb') as apt_conf:
            apt_conf.write(apt_conf_contents)
            apt_conf.close()
            self.unattended_upgrades_ctx = context
            self.unattended_upgrades_cmd = await start_curtin_command(
                self.app, context, "in-target", "-t", self.tpath(),
                "--", "unattended-upgrades", "-v")
            await self.unattended_upgrades_cmd.wait()
            self.unattended_upgrades_cmd = None
            self.unattended_upgrades_ctx = None

    async def stop_unattended_upgrades(self):
        with self.unattended_upgrades_ctx.parent.child(
                "stop_unattended_upgrades",
                "cancelling update"):
            await self.app.command_runner.run([
                'chroot', self.tpath(),
                '/usr/share/unattended-upgrades/'
                'unattended-upgrade-shutdown',
                '--stop-only',
                ])
            if self.app.opts.dry_run and \
               self.unattended_upgrades_cmd is not None:
                self.unattended_upgrades_cmd.proc.terminate()

    async def configure_apt_POST(self, context):
        # Configure apt so that installs from the pool on the cdrom are
        # preferred during installation but not in the installed system.
        #
        # This has a few steps.
        #
        # 1. As the remaining steps mean that any changes to apt configuration
        #    are do not persist into the installed system, we get curtin to
        #    configure apt a bit earlier than it would by default.
        #
        # 2. Bind-mount the cdrom into the installed system as /cdrom.
        #
        # 3. Set up an overlay over /target/etc/apt. This means that any
        #    changes we make will not persist into the installed system and we
        #    do not have to worry about cleaning up after ourselves.
        #
        # 4. Configure apt in /target to look at the pool on the cdrom.  This
        #    has two subcases:
        #
        #     a. if we expect the network to be working, this basically means
        #        prepending
        #        "deb file:///run/cdrom $(lsb_release -sc) main restricted"
        #        to the sources.list file.
        #
        #     b. if the network is not expected to be working, we replace the
        #        sources.list with a file just referencing the cdrom.
        #
        # 5. If the network is not expected to be working, we also set up an
        #    overlay over /target/var/lib/apt/lists (if the network is working,
        #    we'll run "apt update" after the /target/etc/apt overlay has been
        #    cleared).

        async def mount(device, mountpoint, options=None, type=None):
            opts = []
            if options is not None:
                opts.extend(['-o', options])
            if type is not None:
                opts.extend(['-t', type])
            await self.app.command_runner.run(
                ['mount'] + opts + [device, mountpoint])

        async def unmount(mountpoint):
            await self.app.command_runner.run(['umount', mountpoint])

        async def setup_overlay(dir):
            tdir = tempfile.mkdtemp()
            w = f'{tdir}/work'
            u = f'{tdir}/upper'
            for d in w, u:
                os.mkdir(d)
            await mount(
                'overlay', dir, type='overlay',
                options=f'lowerdir={dir},upperdir={u},workdir={w}')

        await run_curtin_command(
            self.app, context, 'apt-config', '-t', self.tpath(),
            config=self.config_location)

        await setup_overlay(self.tpath('etc/apt'))

        os.mkdir(self.tpath('cdrom'))
        await mount('/cdrom', self.tpath('cdrom'), options='bind')

        if self.model.network.has_network:
            os.rename(
                self.tpath('etc/apt/sources.list'),
                self.tpath('etc/apt/sources.list.d/original.list'))
        else:
            os.unlink(self.tpath('etc/apt/apt.conf.d/90curtin-aptproxy'))
            await setup_overlay(self.tpath('var/lib/apt/lists'))

        codename = lsb_release()['codename']

        write_file(
            self.tpath('etc/apt/sources.list'),
            f'deb [check-date=no] file:///cdrom {codename} main restricted\n',
            )

        await run_curtin_command(
            self.app, context, "in-target", "-t", self.tpath(),
            "--", "apt-get", "update")


uu_apt_conf = b"""\
# Config for the unattended-upgrades run to avoid failing on battery power or
# a metered connection.
Unattended-Upgrade::OnlyOnACPower "false";
Unattended-Upgrade::Skip-Updates-On-Metered-Connections "true";
"""

uu_apt_conf_update_security = b"""\
# A copy of the current default unattended-upgrades config to grab
# security.
Unattended-Upgrade::Allowed-Origins {
        "${distro_id}:${distro_codename}";
        "${distro_id}:${distro_codename}-security";
        "${distro_id}ESMApps:${distro_codename}-apps-security";
        "${distro_id}ESM:${distro_codename}-infra-security";
};
"""

uu_apt_conf_update_all = b"""\
# A modified version of the unattended-upgrades default Allowed-Origins
# to include updates in the permitted origins.
Unattended-Upgrade::Allowed-Origins {
        "${distro_id}:${distro_codename}";
        "${distro_id}:${distro_codename}-updates";
        "${distro_id}:${distro_codename}-security";
        "${distro_id}ESMApps:${distro_codename}-apps-security";
        "${distro_id}ESM:${distro_codename}-infra-security";
};
"""
